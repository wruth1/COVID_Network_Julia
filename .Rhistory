# plot(CII_hist_group_free)
# dev.off()
q <- seq(0, 1, by = 1/num_students)
q
w <- data.frame(q = q)
plot(CII_hist_group_free)
w %>%
filter(q > 0.88, q < 0.94) %>%
length()
w %>%
filter(q > 0.88, q < 0.94) %>%
unlist() %>%
length()
plot(CII_hist_group_free)
inf_vals_raw <- seq(0, 1, by = 1/num_students)
inf_vals <- data.frame(val = inf_vals_raw)
inf_vals %>%
filter(q > 0.88, q < 0.94) %>%
unlist() %>%
length()
possible_vals_raw <- seq(0, 1, by = 1/num_students)
possible_vals <- data.frame(val = possible_vals_raw)
inf_vals <- possible_vals %>%
filter(q > 0.88, q < 0.94)
inf_vals
inf_vals <- possible_vals %>%
filter(q > 0.88, q < 0.94) %>%
unlist()
inf_props <- data_logit %>%
filter(threshold == "inf") %>%
select(prop) %>%
unlist()
inf_props
unique(inf_props)
obs_inf_vals <- inf_props %>%
unique() %>%
sort()
obs_inf_vals
length(obs_inf_vals)
length(inf_props)
length(inf_vals)
?%in%
obs_inf_vals %in% inf_vals
knitr::opts_chunk$set(echo = FALSE)
library(knitr)
library(dplyr)
library(magrittr)
library(ggplot2)
library(gridExtra)
library(purrr)
library(tibble)
library(ggfortify) # ggplot version of regression diagnostics
library(latex2exp) # Use latex for plot labels with the TeX() function
library(xtable)    # Create latex tables
num_students <- 25627
data <-
read.csv("D:/School/Thesis/COVID_Network_Julia/Data/Output/All_Outbreak_Sizes.csv")
num_trials = nrow(data)
# Number of students remaining in the network for each threshold level
network_sizes <- c(16866, 23660, 24752, 25627)
# ------------- Replace infinity character in threshold variable ------------- #
thresh <- data$threshold
inds_thresh <- thresh == unique(thresh)[4]
data[inds_thresh, "threshold"] <- "inf"
data$threshold = factor(data$threshold, levels = c("20", "50", "100", "inf"))
all_thresholds <- unique(data$threshold)
thresh2size <- function(thresh){
switch(thresh,
"20" = network_sizes[1],
"50" = network_sizes[2],
"100" = network_sizes[3],
"inf" = network_sizes[4],
stop("Invalid threshold level."))
}
for (i in 1:(ncol(data)-1)) {
data[, i] <- factor(data[, i])
}
for (i in 1:(ncol(data)-2)) {
levels(data[,i]) <- c("low", "med", "high")
}
get_formula <- function(resp_var, control_var, data, int = TRUE){
model_vars = data %>%
select(-!!resp_var, -!!control_var) %>%
names()
# First-order terms
(form_str <- paste(model_vars, collapse = " + "))
(form_str <- paste(control_var, form_str, sep = " + "))
(form_str <- paste(resp_var, form_str, sep = " ~ "))
# Second-order terms. Only include interactions with the control variable
if (int) {
(form_int_str <- paste(model_vars, control_var, sep = "*"))
(form_int_str <- paste(form_int_str, collapse = " + "))
(form_str <- paste(form_str, form_int_str, sep = " + "))
}
# Convert string to formula object
form = formula(form_str)
form
}
### Build vector of proportions
group_size <- num_trials/4
all_network_sizes <- rep(network_sizes,
each = group_size)
data_logit_raw <- data %>%
arrange(threshold) %>%
mutate(network_size = all_network_sizes,
prop = size / network_size) %>%
select(-size, -network_size)
### Use logistic regression to model proportion who are ever infected
## Build formula for logistic regression
form = get_formula("prop", "threshold", data_logit_raw)
## Fit model with and without interactions
fit_glm_main <- glm(prop ~ ., family = binomial(),
data = data_logit_raw, weights = rep(network_sizes, each = group_size))
fit_glm_int <- glm(form, family = binomial(),
data = data_logit_raw, weights = rep(network_sizes, each = group_size))
fit_glm_main_disper <- glm(prop ~ ., family = quasibinomial(),
data = data_logit_raw, weights = rep(network_sizes, each = group_size))
fit_glm_int_disper <- glm(form, family = quasibinomial(),
data = data_logit_raw, weights = rep(network_sizes, each = group_size))
## Extract fitted proportions from models with interactions
p_hat_int = predict(fit_glm_int, type = "response")
p_hat_int_disper = predict(fit_glm_int_disper, type = "response")
### Estimate SD of Y in each group empirically
all_SDs_obs_raw = data_logit_raw %>%
add_column(p_hat_int = p_hat_int, p_hat_disp = p_hat_int_disper) %>%
group_by(across(infect_prop_A:threshold)) %>%
summarise(p_hat_obs = mean(prop), SD_obs = sd(prop),
p_hat_int = mean(p_hat_int), p_hat_disp = mean(p_hat_disp),
.groups="drop") %>%
mutate(SD_theo = sqrt(p_hat_int * (1 - p_hat_int)/sqrt(num_students)),
SD_disp = (p_hat_disp * (1 - p_hat_disp)/sqrt(num_students)))
all_SDs_obs <- filter(all_SDs_obs_raw,
!((threshold == "100") & (SD_obs > 0.15)))
### Remove extreme outlier from original data frame
row_remove <- all_SDs_obs_raw %>%
filter((threshold == "100") & (SD_obs > 0.15)) %>%
select(infect_prop_A:threshold)
data_logit <- data_logit_raw %>%
filter(!((infect_prop_A %in% row_remove[[1]]) &
(infect_prop_I1 %in% row_remove[[2]]) &
(infect_param_I2 %in% row_remove[[3]]) &
(advance_prob_E %in% row_remove[[4]]) &
(advance_prob_A %in% row_remove[[5]]) &
(advance_prob_I1 %in% row_remove[[6]]) &
(advance_prob_I2 %in% row_remove[[7]]) &
(E_to_A_prob %in% row_remove[[8]]) &
(threshold %in% row_remove[[9]])
))
# # This method also works, but is much slower
# pred_vars <- setdiff(names(data_logit_raw), c("prop"))
# check <- pbapply(data_logit_raw, 1, function(X){
#   all(X[pred_vars] == row_remove)
# })
# data_logit <- data_logit_raw[!check,]
### Plot a histogram of CIIs across all simulations
CII_hist <- ggplot(data_logit, aes(x = prop)) +
geom_histogram(bins = 500) + xlab("CII")
# geom_histogram(aes(y = after_stat(density)), bins = 500)
plot(CII_hist)
### Subdivide by class size threshold
CII_hist_group <- CII_hist +
facet_wrap(~threshold) + xlim(0,1)
plot(CII_hist_group)
jpeg("D:\\SFU Vault\\CornellStudy\\Tex\\Plots\\CII_Analysis\\CII_hist_homo.jpeg")
plot(CII_hist_group)
dev.off()
source("D:/School/Thesis/COVID_Network_Julia/Data Analysis/CII Tree Fit/CII Tree Fit - All Thresholds.R")
### Summaries of CV trees
xtable(CV_summ,
caption = "Summaries of CV-tuned trees across class size thresholds.",
label = "tab:CII_CV_Trees")
source("D:/School/Thesis/COVID_Network_Julia/Data Analysis/Peak Tree Fit/Peak Tree Fit - All Thresholds.R")
global_GOF
errs_small
this_thresh
tree_sizes
errs_small
info
print(info$nsplit)
errs_small
source("D:/School/Thesis/COVID_Network_Julia/Data Analysis/Peak Tree Fit/Peak Tree Fit - All Thresholds.R")
versioninfo()
version()
??version
R.version
library(installr)
install.packages("installr")
library(installr)
updateR()
source("D:/School/Thesis/COVID_Network_Julia/Data Analysis/Peak Tree Fit/Peak Tree Fit - All Thresholds.R")
knitr::opts_chunk$set(echo = FALSE)
library(knitr)
library(dplyr)
library(magrittr)
library(ggplot2)
library(gridExtra)
library(purrr)
library(tibble)
library(ggfortify) # ggplot version of regression diagnostics
library(latex2exp) # Use latex for plot labels with the TeX() function
library(xtable)    # Create latex tables
num_students <- 25627
data <-
read.csv("D:/School/Thesis/COVID_Network_Julia/Data/Output/All_Outbreak_Sizes.csv")
num_trials = nrow(data)
# Number of students remaining in the network for each threshold level
network_sizes <- c(16866, 23660, 24752, 25627)
# ------------- Replace infinity character in threshold variable ------------- #
thresh <- data$threshold
inds_thresh <- thresh == unique(thresh)[4]
data[inds_thresh, "threshold"] <- "inf"
data$threshold = factor(data$threshold, levels = c("20", "50", "100", "inf"))
all_thresholds <- unique(data$threshold)
thresh2size <- function(thresh){
switch(thresh,
"20" = network_sizes[1],
"50" = network_sizes[2],
"100" = network_sizes[3],
"inf" = network_sizes[4],
stop("Invalid threshold level."))
}
for (i in 1:(ncol(data)-1)) {
data[, i] <- factor(data[, i])
}
for (i in 1:(ncol(data)-2)) {
levels(data[,i]) <- c("low", "med", "high")
}
get_formula <- function(resp_var, control_var, data, int = TRUE){
model_vars = data %>%
select(-!!resp_var, -!!control_var) %>%
names()
# First-order terms
(form_str <- paste(model_vars, collapse = " + "))
(form_str <- paste(control_var, form_str, sep = " + "))
(form_str <- paste(resp_var, form_str, sep = " ~ "))
# Second-order terms. Only include interactions with the control variable
if (int) {
(form_int_str <- paste(model_vars, control_var, sep = "*"))
(form_int_str <- paste(form_int_str, collapse = " + "))
(form_str <- paste(form_str, form_int_str, sep = " + "))
}
# Convert string to formula object
form = formula(form_str)
form
}
### Build vector of proportions
group_size <- num_trials/4
all_network_sizes <- rep(network_sizes,
each = group_size)
data_logit_raw <- data %>%
arrange(threshold) %>%
mutate(network_size = all_network_sizes,
prop = size / network_size) %>%
select(-size, -network_size)
### Use logistic regression to model proportion who are ever infected
## Build formula for logistic regression
form = get_formula("prop", "threshold", data_logit_raw)
## Fit model with and without interactions
fit_glm_main <- glm(prop ~ ., family = binomial(),
data = data_logit_raw, weights = rep(network_sizes, each = group_size))
fit_glm_int <- glm(form, family = binomial(),
data = data_logit_raw, weights = rep(network_sizes, each = group_size))
fit_glm_main_disper <- glm(prop ~ ., family = quasibinomial(),
data = data_logit_raw, weights = rep(network_sizes, each = group_size))
fit_glm_int_disper <- glm(form, family = quasibinomial(),
data = data_logit_raw, weights = rep(network_sizes, each = group_size))
## Extract fitted proportions from models with interactions
p_hat_int = predict(fit_glm_int, type = "response")
p_hat_int_disper = predict(fit_glm_int_disper, type = "response")
### Estimate SD of Y in each group empirically
all_SDs_obs_raw = data_logit_raw %>%
add_column(p_hat_int = p_hat_int, p_hat_disp = p_hat_int_disper) %>%
group_by(across(infect_prop_A:threshold)) %>%
summarise(p_hat_obs = mean(prop), SD_obs = sd(prop),
p_hat_int = mean(p_hat_int), p_hat_disp = mean(p_hat_disp),
.groups="drop") %>%
mutate(SD_theo = sqrt(p_hat_int * (1 - p_hat_int)/sqrt(num_students)),
SD_disp = (p_hat_disp * (1 - p_hat_disp)/sqrt(num_students)))
all_SDs_obs <- filter(all_SDs_obs_raw,
!((threshold == "100") & (SD_obs > 0.15)))
### Remove extreme outlier from original data frame
row_remove <- all_SDs_obs_raw %>%
filter((threshold == "100") & (SD_obs > 0.15)) %>%
select(infect_prop_A:threshold)
data_logit <- data_logit_raw %>%
filter(!((infect_prop_A %in% row_remove[[1]]) &
(infect_prop_I1 %in% row_remove[[2]]) &
(infect_param_I2 %in% row_remove[[3]]) &
(advance_prob_E %in% row_remove[[4]]) &
(advance_prob_A %in% row_remove[[5]]) &
(advance_prob_I1 %in% row_remove[[6]]) &
(advance_prob_I2 %in% row_remove[[7]]) &
(E_to_A_prob %in% row_remove[[8]]) &
(threshold %in% row_remove[[9]])
))
# # This method also works, but is much slower
# pred_vars <- setdiff(names(data_logit_raw), c("prop"))
# check <- pbapply(data_logit_raw, 1, function(X){
#   all(X[pred_vars] == row_remove)
# })
# data_logit <- data_logit_raw[!check,]
### Plot a histogram of CIIs across all simulations
CII_hist <- ggplot(data_logit, aes(x = prop)) +
geom_histogram(bins = 2000) + xlab("CII")
# geom_histogram(aes(y = after_stat(density)), bins = 500)
plot(CII_hist)
### Subdivide by class size threshold
CII_hist_group <- CII_hist +
facet_wrap(~threshold) + xlim(0,1)
plot(CII_hist_group)
### Subdivide by class size threshold, and use free axis labels
CII_hist_group_free <- CII_hist +
facet_wrap(~threshold, scales = "free")
plot(CII_hist_group_free)
?geom_histogram
### Subdivide by class size threshold, and use free axis labels
CII_hist_group_free <- CII_hist +
facet_wrap(~threshold, scales = "free") +
geom_histogram(binwidth = 1/num_students)
plot(CII_hist_group_free)
### Plot a histogram of CIIs across all simulations
CII_hist <- ggplot(data_logit, aes(x = prop)) +
geom_histogram(binwidth = 1/num_students) + xlab("CII")
plot(CII_hist)
### Plot a histogram of CIIs across all simulations
CII_hist <- ggplot(data_logit, aes(x = prop)) +
geom_histogram(bins = 500) + xlab("CII")
plot(CII_hist)
### Subdivide by class size threshold
CII_hist_group <- CII_hist +
facet_wrap(~threshold) + xlim(0,1)
plot(CII_hist_group)
### Subdivide by class size threshold, and use free axis labels
CII_hist_group_free <- CII_hist +
facet_wrap(~threshold, scales = "free") +
geom_histogram(binwidth = 1/num_students)
plot(CII_hist_group_free)
### Subdivide by class size threshold, and use free axis labels
CII_hist_group_free <- ggplot(data_logit, aes(x = prop)) +
facet_wrap(~threshold, scales = "free") +
geom_histogram(binwidth = 1/num_students)
plot(CII_hist_group_free)
all_hists <- list()
for(i in seq_along(all_thresholds)){
this_thresh <- all_thresholds[i]
this_data <- data_logit %>%
filter(threshold == this_thresh)
this_plot <- ggplot(this_data, aes(x = prop)) +
xlab("CII")
if(this_thresh == "inf"){
this_plot <- this_plot + geom_histogram(binwidth = 1/num_students)
} else{
this_plot <- this_plot + geom_histogram(bins = 500)
}
all_hists[[i]] <- this_plot
}
?grid.arrange
all_hists
## First, construct the four plots
all_hists <- list()
for(i in seq_along(all_thresholds)){
this_thresh <- all_thresholds[i]
this_data <- data_logit %>%
filter(threshold == this_thresh)
this_plot <- ggplot(this_data, aes(x = prop)) +
xlab("CII")
if(this_thresh == "inf"){
this_plot <- this_plot + geom_histogram(binwidth = 2/num_students)
} else{
this_plot <- this_plot + geom_histogram(bins = 500)
}
all_hists[[i]] <- this_plot
}
all_hists[[4]]
num_students
num_students * 0.06
## First, construct the four plots
all_hists <- list()
for(i in seq_along(all_thresholds)){
this_thresh <- all_thresholds[i]
this_data <- data_logit %>%
filter(threshold == this_thresh)
this_plot <- ggplot(this_data, aes(x = prop)) +
xlab("CII")
if(this_thresh == "inf"){
this_plot <- this_plot + geom_histogram(binwidth = 2/num_students)
} else{
this_plot <- this_plot + geom_histogram(bins = 1500)
}
all_hists[[i]] <- this_plot
}
all_hists
## First, construct the four plots
all_hists <- list()
for(i in seq_along(all_thresholds)){
this_thresh <- all_thresholds[i]
this_data <- data_logit %>%
filter(threshold == this_thresh)
this_plot <- ggplot(this_data, aes(x = prop)) +
xlab("CII")
if(this_thresh == "inf"){
this_plot <- this_plot + geom_histogram(binwidth = 2/num_students)
} else{
this_plot <- this_plot + geom_histogram(bins = 500)
}
all_hists[[i]] <- this_plot
}
grid.arrange(all_hists, ncol = 2)
arrangeGrob(all_hists, ncol = 2)
arrangeGrob(all_hists, nrow = 2, ncol = 2)
q <- all_hists
w <- unlist(q)
w
?unlist
w <- unlist(q, recursive = F)
w
str(w)
grid.arrange(grobs = all_hists, nrow = 2, ncol = 2)
## First, construct the four plots
all_hists <- list()
for(i in seq_along(all_thresholds)){
this_thresh <- all_thresholds[i]
this_data <- data_logit %>%
filter(threshold == this_thresh)
this_plot <- ggplot(this_data, aes(x = prop)) +
xlab("CII") + theme(plot.title = element_text(hjust = 0.5)) +
ggtitle(this_thresh)
if(this_thresh == "inf"){
this_plot <- this_plot + geom_histogram(binwidth = 2/num_students)
} else{
this_plot <- this_plot + geom_histogram(bins = 500)
}
all_hists[[i]] <- this_plot
}
grid.arrange(grobs = all_hists, nrow = 2, ncol = 2)
all_hists_fixed <- list()
for(i in seq_along(all_thresholds)){
this_thresh <- all_thresholds[i]
this_data <- data_logit %>%
filter(threshold == this_thresh)
this_plot <- ggplot(this_data, aes(x = prop)) +
xlab("CII") + theme(plot.title = element_text(hjust = 0.5)) +
ggtitle(this_thresh) + xlim(0, 1) + geom_histogram(bins = 500)
all_hists_fixed[[i]] <- this_plot
}
CII_hist_group_fixed <- grid.arrange(grobs = all_hists_fixed, nrow = 2, ncol = 2)
?grob
?gtable
CII_hist_group_free <- grid.arrange(grobs = all_hists_free, nrow = 2, ncol = 2,
rownames = "Test")
## First, construct the four plots
all_hists_free <- list()
for(i in seq_along(all_thresholds)){
this_thresh <- all_thresholds[i]
this_data <- data_logit %>%
filter(threshold == this_thresh)
this_plot <- ggplot(this_data, aes(x = prop)) +
xlab("CII") + theme(plot.title = element_text(hjust = 0.5)) +
ggtitle(this_thresh)
if(this_thresh == "inf"){
this_plot <- this_plot + geom_histogram(binwidth = 2/num_students)
} else{
this_plot <- this_plot + geom_histogram(bins = 500)
}
all_hists_free[[i]] <- this_plot
}
CII_hist_group_free <- grid.arrange(grobs = all_hists_free, nrow = 2, ncol = 2,
rownames = "Test")
?ggsave
ggsave("D:\\SFU Vault\\CornellStudy\\Tex\\Plots\\CII_Analysis\\CII_hist_hetero.jpeg",
plot = CII_hist_group_free)
knitr::opts_chunk$set(echo = FALSE)
library(knitr)
library(dplyr)
library(magrittr)
library(ggplot2)
library(gridExtra)
library(purrr)
library(tibble)
library(ggfortify) # ggplot version of regression diagnostics
library(latex2exp) # Use latex for plot labels with the TeX() function
library(xtable)    # Create latex tables
num_students <- 25627
data <- read.csv("C:/Users/willi/Desktop/School/Thesis/COVID_Network_Julia/Data/Output/All_Outbreak_Peaks.csv")
source("D:/School/Thesis/COVID_Network_Julia/Data Analysis/Peak Tree Fit/Peak Tree Fit - All Thresholds.R")
### CV-RMSEs
xtable(global_GOF,
caption = "CV-RMSE for predicting logit-peak-size using selected trees across class size thresholds. *CV-RMSEs for trees chosen based on this metric are optimisitically biased.",
label = "tab:peak_GOF")
### Summaries of CV trees
xtable(CV_summ,
caption = "Summaries of CV-tuned trees for predicting peak outbreak size across class size thresholds.",
label = "tab:peak_CV_Trees")
### Summaries of CV trees
xtable(CV_summ,
caption = "Summaries of CV-tuned trees for predicting CII across class size thresholds.",
label = "tab:CII_CV_Trees")
for(thresh in all_thresholds){
this_imps <- global_variable_importances[[thresh]]
print(xtable(this_imps))
}
### CV-RMSEs
xtable(global_GOF,
caption = "CV-RMSE for predicting logit-CII using selected trees across class size thresholds. *CV-RMSEs for trees chosen based on this metric are optimisitically biased.",
label = "tab:CII_GOF")
source("D:/SFU Vault/STAT 300 - Spring 2022/Grade Script.R")
source("D:/SFU Vault/STAT 300 - Spring 2022/Grade Script.R")
source("D:/SFU Vault/STAT 300 - Spring 2022/Grade Script.R")
source("D:/SFU Vault/STAT 300 - Spring 2022/Grade Script.R")
source("D:/SFU Vault/STAT 300 - Spring 2022/Grade Script.R")
source("D:/SFU Vault/STAT 300 - Spring 2022/Grade Script.R")
source("D:/SFU Vault/STAT 300 - Spring 2022/Grade Script.R")
